ctrl + shift + F10 -> pokrecemo fajl
sout -> System.out.println()
psvm -> main method
tab -> dopuna
ctrl + shift + / -> block code
ctrl + alt + l -> reformat code
alt + insert => Generate constructors, getters, setters...
obelezim rec, desni klik refactor - renamme i onda u celoj klasi menja
                - pita za getter da li promeniti
public static final String INVALID_STRING = "Invalid Value";
refactor -> copy class
right click -> refactor -> move -> make inner class of

################################################################
6.10.2021:
    * 36. Logical AND operator
        && u if klauzuli kada tesiramo dva uslova
        Lakse za citanje - odvojiti u zagrade levu i desnu stranu
    * 37. Logical OR operator
        ||
    * 38. Assignment Operator VS Eaquals to Operator
        Ako za ne boolean vrednost stavimo
            if (prom = neki_br)
        prijavice gresku
        Za boolean vrednost nece prijaviti gresku vec
        tu vrednost dodeliti
            if (isCar = true) -> procice

        Pojednostavljenje ispisa za boolean:
            if(isCar) -> da li je true
            if(!isCar) -> da li nije

    * 39. Ternary Operator
        boolean wasCar = isCar ? true : false;

    * 40. Operator Precedence and Operator Challenge
        -> link summary of operators oracle sajt
        -> Java operatorc precedence table -> prioritet operatora

    * 41. First steps summary
    * 42. End of remaster

    // Section 4
    * 43. Introduction

    * 44. Keywords and Expressions
        -> link list of Java keywords
        Expressions are building blocks of all Java programms, built
            with variables, values and operators, also with method calls
        When we add a valid Java datatype in front of an expression we create
        a valid Java statement (and a semicolon on the end)

    * 45. Statements, whitespace and indentation
        Statements: assignment, method calls
                    usually ends with ;
                    it can be in more than one line
                    it can be more statements in one line but is not easy readable

        Whitespace: space around operators, statements, etc.
                    Java doesn't mind how many we have it deletes them internaly

        Indentation: to make code readable, to show the code flow
                    in IntelliJ: Code-> Reformat Code == Ctrl + Alt + L

    * 46. Code blocks and the if then else control statements
        if statement: when we have one line we can write without {} but it is
        recomended to use it always so we don't forget to add it if we add more
        to our if

        code block: we can use variables created outside the block, but variables
                    created inside it can't be used outside that block
        inside code block = scope

        Disadvantages when changing variables to count another result:
         copying code and losing info about previous values,
         duplicating code -> we can forget to change code in all places.
    * 47. if then else recap
          /
        \/
########################################################################
7.10.2021.

    * 48. Methods
        We can't put method inside another method.
        It has to be inside class.

        void - don't return anything
        return -1 -> in programming it indicates some error,
                     in search algorithms it's value not found

    * 49. More on methods and a challenge
        void method is usually known as a procedure
        method which returns something is known as a function
        think about edge cases

    * 50. Method challenge - final code changes

    * 51. DiffMerge Tool Introduction
        -> program that helps you to visually compare and merge files on any OS
        -> ex. it helps when you make a typo and get stuck
        -> After download of his code using DiffMerge we can find where we are stuck
        -> we can compare files and even whole folder

    * 52. Install DiffMerge
        Link: sourcegear.com/diffmerge

    * 53. Using DiffMerge
        Folder with code and second with mistake
        Open DiffMerge
        Choose folders or files you want to compare
        There is option to apply changes from the left and then save them.

    * 54. Coding exercises
        SampleCodingexercise
            src -> desni klik -> new Java class
        Coding exercise doesn't need main but we can use it to test

    * 55. Coding exercises Example part 1
        new project without template -> Speed converter
        2 classes in src -> SpeedConverter.java and Main.java

        redundant - we calculated and then returned it, insetead we can only return the calculation

    * 56. Coding exercises Example part 2
        -> another method
        In Main psvm -> main method
        For calling out methods class.method

    * 57. Coding exercises Example part 3
        -> in Udemy tests the code

    *  Coding exercise 1: Speed Converter
        -> Entered it in Udemy

    *  Coding exercise 2: MegaBytes Converter
    *  Coding exercise 3: Barking Dog
    *  Coding exercise 4: Leap Year Calculator
    *  Coding exercise 5: Decimal Comparator
    *  Coding exercise 6: Equal Sum Checker
    *  Coding exercise 7: Teen Number Checker

################################################################
10.10.2021
    * 58. Method Overloading
        -> use same method name but with different parameters
        -> in case there is method with certain number of parameters and we create
            another just like that but with different return type ERROR!!
        -> when transforming inches to feet and inches since we need remainers
            it can be done
            double feet = (int) inches/12; -> then int is cast to double

    * 59. Method Overloading Recap
        In method overloading we can call the method with differenc number
        of parameters
        println -> example of method overloading
        -> improves code readability and re-usability
        -> easier to remember one method name instead of multiple names
        -> achieves consistency in naming
        -> give programmers flexibility to call a similar method with different
        types of data

    * 60. Seconds and Minutes Challenge
    * 61. Bonus part for Challenge
        constant for invalid value string => needs to be outside methods
        We can't assign value to the final value

#################################################################
11.10.2021.
    * Coding exercise 8: Area Calculator
    * Coding exercise 9: Minutes to Years and Days Calculator
    * Coding exercise 10: Equality Printer
    * Coding exercise 11: Playing Cat

  ============================================================
  SECTION 5: Control Flow Statements
    * 62: Intro
    * 63. Switch statement
        If we forget break statement we get unpredictable result.
        Can be used with 4 primitive types: byte, short, char or int
        From JDK 7 String can be used -> problem if we test January and someone enters
                        january. ==> solution month.toLowerCase()
    * 64. Day of the Week Challenge
    * Coding Exercise 12: Number in Word
    * Coding Exercise 13: Number of Days in Month
    * 65. For statement
        Precision for double -> String.format("%.2f", number)
    * 66. For loop recap
    * 67. Sum 3 and 5 Challenge
    * Coding Exercise 14: Sum Odd
###########################################################################
12.10.2021.
    * 68. While and do while statements
        do while -> executes at least once
        continue -> bypass the rest of the code and goes back to begining of loop
    * 69. While and Do While recap
    * 70. Digit Sum Challenge
###########################################################################
15.10.2021.
    * Coding Exercise 15: Number Palindrome
    * Coding Exercise 16: First and last digit sum
    * Coding Exercise 17: Even digit sum
    * Coding Exercise 18: Shared digit
    * Coding Exercise 19: Last digit checker
    * Coding Exercise 20: Greatest common divisor
    * Coding Exercise 21: All factors
    * Coding Exercise 22: Perfect Number
    * Coding Exercise 23: Number to words
    * 71. Parsing Values as String
           int number = Integer.parseInt(numberAsString)
           Integer -> class Integer
           We can parse String as any primitive type

           string += number -> ex. "123" + 1 = "1231" concatenes
           number += numb -> ex. 123 + 1 = 124

    * Coding Exercise 24: Flour Pack Problem
    * Coding Exercise 25: Largest Prime
    * Coding Exercise 26: Diagonal Star
    * 72. Reading User Input
        Scanner class -> import java.util.Scanner; !!!
        Scanner scanner = new Scanner(System.in); -> new instance, object of Scanner
        Always close the scanner after we use it!!
        nextLine() reading after enter (for now handle like that)

    * 73. Problems and Solutions
        -> What if negative input or letters instead of numbers?
            -> add condition to check
    * 74. Reading User input challenge
        while(true) --> or while(counter <=10) to avoid break
        break to exit the loop
        scanner.nextLine() -> to handle enter and avoid infinite loop
####################################################################
17.10.2021.

    * 75. Min and Max Challenge
        One solution is to use flag to insure to use entered numbers
        Second one is to set min to max val int can hold, and same for max
        min = 2147483647
        max = -2147483648
            Or constant int min = Integer.MAX_VALUE;
                        int max = Integer.MIN_VALUE;

    * Coding Exercise 27: Input Calculator
    * Coding Exercise 28: Paint Job

    =====================================================
    SECTION 6: OOP Part 1 - Classes, Constructors and Inheritance
    * 76. Introduction
    * 77. Classes Part 1
        2 major characteristics of objects -> behaviour and state
        class -> like a template or blueprint for creating objects

        On package name right click => new class => Name of class with capital letter

        On the left -> Project -> find class we want and right click -> open in explorer
                    -> we see all the classes created for that project in said package

        public - unrestricted access to your class
        private -> non other can access
        protected - others from the same package can access

        fields inside class are private (private int doors, private String model...)

        after we create new object (in Main) we can access a bunch of methods that Java
                creates when class is created ex. .equals, .notify, .wait...
#########################################################################
19.10.2021.
    * 78. Classes Part 2
        Creating Setters -> method public void setModel, to set a value
        this.field = ...
        Creating Getter -> it needs to return value
            InteliJ tells us type -> f = field, p = paramater...
            null is default before we set the values (for any field)

    * Coding Exercise 29: Sum Calculator
    * Coding Exercise 30: Person
#########################################################################
22.10.2021.
    * 79. Constructors Part1
        Code -> Generate -> Getters and Setters
        Constructor - creates a class. Only has access modifier
                    - to initialize our Object
                    - only called once
                    - they can be overloaded - just change number of params
                    - to set default values to fields in empty constructor call
                    this(... here goes values... )
                    this HAS to be the very first line executed
                        sout in empty and sout i full version, firstly the full
                        one will be desplayed then empty
    * 80. Constructors Part2
        In constructors we can use setters ('cause in setters
        we can have some checkings of values etc.) DON'T DO THIS
        But generally it's better to set values directly from
        the field. In inheritance we'll see that sometimes code
        from setters doesn't execute

        Code -> Generate -> Constructors and select fields

        Good way:
            Create one major constructor and then in all other constructors
            call that one.
###########################################################################
26.10.2021.
    * CE 32: Wall Area
    * CE 33: Point
    * CE 34: Carpet Cost Calculator
    * CE 35: Complex Operations
    * 81. Inheritance Part1
         alt + insert => Generate constructors, getters, setters...
        Animal - base class, other types of animals are subclasses
        subclass:
            public class Dog extends Animal
            constructor -> super(params...)
            can have additional params/fields

            override methods

    * 82. Inheritance Part2
        If we override method ex. move
        and in one method we call super.move() and in other move()
        First is called move from Dog class.
        So move() calles overriden method which calls super, and second one only super

        And if it's not overriden move calls the super one

        you don't have to call the code in the super class

    * 83. Reference vs Object vs Instance vs Class
        object - blueprint, how we define object
        instance - when we create one object of that class
                - each time creating object of class or copying
        Object - when created new instance
        reference - points to an object, more references can point to same object

        House blueHouse = new House(blue) - object, instance
        House anotherBlue = blueHouse - instance, reference

        anotherBlue = greenHouse --> dereferencing

    * 84. this vs super
         - CAN'T use them in static areas (static block or static method)
                --> leads to compile-time errors
         this - in constructors and setters, in getters it's optional

         this() - to call a constructor from another overloaded constructor in the same class
                - only in constructor, must be first statement
                - helps reduce duplicated code, used with constructor chaining
         super() - calls parent constructor
                 - first statement in constructor!!

         Even Abstract classes have constructors athough you can never instantiate an
         abstract class using the new keyword
         Abstract class is still a super class, so its constructors run when someone makes
         an instance of concrete subclass

         Constructor can have a call to super() or this() but NEVER both
######################################################################
27.10.2021.
    * 85. Method Overloading and Overriding Recap
        - Overloading doesn't have anything to do with polymorphism but
        often refered ad Compile Time Polymorphism
        - Overloading rules:
            1. must have same mathod name
            2. must have different parameters
            - may or may not: have different return types, different access modifiers
                throw different checked or unchecked exceptions
        - Overriding - same name, same arguments as parent class, derived methods
                     - known as Runtime Polymorphism and Dynamic Method Dispatch
        - Overriding rules:
            1. must have same name and same arguments
            2. return type can be a subclass of the return type in the parent class
            3. can't have a lower acccess modifier
                (ex. parent - protected, child can't be private but can be public)
        Covariant return type:
            class Burger{...}
            class HealthyBurger extends Burger{...}

            class BurgerFactory has method public Burger createBurger(){...}
            class HealthyBurgerFactoty extends BurgerFactory has overriden
                method public HealthyBurger createBurger(){...}
            overriden method has return type which is child class of original (lower class)

    * 86. Static vs Instance Methods
        in static method can't use this keyword, if method doesn't use instance variables
        it should be static method

        static methods call:
            ClassName.methodName(); or
            methodName(); -> only if in the same class

        Instance methods belong to an instance of a class, to use it we firstly have to instantiate
        the class using the new keyword.

    * 87. Static vs Instance Variables
        Every instance of that class shares the same static variable, if changes are made
        to it all other instances will see the effect of the change.
        Can be useful, ex. Scanner can be static var and all static methods can access it.

       EX. of bad:
        class with instance private static String name
        then in main we create 2 instances .. new Dog("rex"), new Dog("fluffy")
        because of static both will be fluffy!

    * 88. Inheritance Challenge Part1 (+ Challenge Exercise)
        java.lang.Object
            Every class has Object as a superclass
            All objects, including arrays, implement the methods of this class

    * 89. Inheritance Challenge Part2
    * CE35: Cylinder
    * CE36: Pool Area

    =======================================================
    SECTION 7: OOP Part2 - Composition, Encapsulation and Polymorphism

    * 90. Introduction
    * 91. Composition
        recap little about inheritance. 2 classes Vehicle, Car extends Vehicle
            there is a "IS A" relationship -> Car is a Vehicle
        Composition deals with "HAS A" relationship
            ex. computer has a motherboard, ram etc. but those are not computers
            - modeling parts of a whole
        If we are not going to use instance more than once we can put creation directly:
            Monitor monitor = new Monitor("27inch Beast", "Acer", 27, new Resolution(2540, 1440));
        instead of making variable for resolution then calling it in monitor.

        Think about what you're trying to do - to build something or to make parts.
#########################################################################
13.11.2021.
   * 92. Composition II
        General rule - look firstly composition
   * CE37: Composition
   * 93. Encapsulation
        Mechanism which allows us to restrict access to certain components we are creating.
        Problems: Player -> 1. every field public, we get to override the class, fidle with the logic
            2. Another problem if we change field name in class and in main we use it then we have to find
                what is it changed to and possibly make a lot of changes.
            3. We can forget to initialize at all a field so we have a problem with all
        EnhancedPlayer
            Now when we have private fields, constructor, getters etc. we can rename
            fields in class and still have our name code runing without changes..
   * 94. Encapsulation - Excercise
   * CE38: Encapsulation
        -> Same as 94
###########################################################################
01.12.2021

    * 95. Polymorphism
        -> mechanism which allows us to execute one action in multiple ways
        -> it is ok to implement multiple classes in one file if they are compact and small
        -> we have a base class and multiple classes which exteds her -> in them we override and that's polymorphism
        -> Inline class -> after instancing a class { with the rest of the class}
        -> Name of a class:
            getClass().getSimpleName()
    * 96. Polymorphism + Challenge Excercise
    * CE 39: Polymorphism = 96
    * 97. OOP Master Challenge Excercise
    * 98. -||- solution
        Better with Lists and Arrays but more on that later
    * CE 40 = 97 & 98
    ======================================================================
    SECTION 8
    =========
